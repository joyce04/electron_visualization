<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>2018-28420 Visualization Assignment 02: </title>
  <style>
    .selected {
      fill: green;
    }
  </style>
</head>
<body>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <svg id="chart" width="200", height="200" class='foo'></svg>
  <svg class='grp'/>
  <svg class='grp'/>
  <svg class='grp'/>
  <div></div>
  <div id='checkbox_group' height='20'>
    <input type="checkbox" name="vehicle1" value="Bike"> I have a bike<br>
  </div>
  <div id='table_container'/>
  <svg id="scatter_plot" style="width: 100%; height: 600px;"></svg>
  <svg id='shape' style="width: 100%; height: 600px;"></svg>
  <script type="text/javascript">
    // python3 -m http.server
    d3.csv('test.csv').then(function(data){
      let sum_a = data.map(k => k['a']).reduce((a, b)=> a + b, 0)
      console.log(sum_a);
    });
    // d3.json('data.json').then(function(data){
    //   // data is inserted in json format
    //   // must convert from string
    //   console.log(k)
    // });

    // d3.selectAll('rect')
    // d3.selectAll('#rect') = id rect
    // d3.selectAll('.rect') = class rect

    //1. chaining
    // d3.select("#table")
    //   .selectAll(".selected")

    //2. adding class
    d3.selectAll('.foo').classed('bar', true);

    d3.selectAll('.foo').classed('bar extra', true);

    // function 일 경우, 각 selection에 대하여 함수의 return에 따라
    // d3.selectAll('.foo')
    //   .attr('class', function(c){
    //     return d3.select(this).attr('class')+' bar'
    //   });

    // class 여부 확인을 위해
    console.log(d3.selectAll('.foo').classed('bar'));

    // 3. each
    d3.selectAll('.grp')
      .each(function(d, i, nodes){
        console.log(d);
        // d = data
        // i = index
        // nodes = selector group, nodes[i] === this
      });

    // 4. call : 호출 바로 앞의 객체를 매개변수로 넘겨준다
    // use for axis and brush drawing
    d3.selectAll('div')
      .call(function(div){
        div.classed('next_div', true);
      });

      const xScale = d3.scaleBand()
                      .rangeRound([0, 100])
                      .domain([1,2,3]);
      const yScale = d3.scaleLinear()
                      .range([100, 0])
                      .domain([0, 5]);

    let svg = d3.select('svg');
    svg.append('g')
      .attr('transform', 'translate(0, 100)')
      .call(d3.axisLeft(yScale))
      .call(d3.axisBottom(xScale));

    // 5. additional properties
    d3.select('#checkbox_group')
      .selectAll('input')
      .property('checked', true);
    let isChecked = d3.select('#checkbox_group')
                      .selectAll('input')
                      .property('checked');
    console.log('check box is checked::: ' + isChecked);

    d3.select('#checkbox_group')
      .select('input')
      .text('this is a check box.');
    console.log(d3.select('#checkbox_group')
                  .select('input')
                  .text());

    console.log(d3.select('#checkbox_group')
                  .html())

    // 6. table
    let mydata = [{a:1, b:2, c:3}, {a:4, b:5, c:6}]
    let keys = Object.keys(mydata[0])

    let table = d3.select('#table_container')
                  .append('table')
                  .attr('id', 'table')
    let thead = table.append('thead')
                      .append('tr')
                      .selectAll('td')
                      .data(keys)
    thead.enter()
          .append('td')
          .merge(thead)
          .text(k => k)

    let tbody = table.append('tbody')
    // tr에 각 row data가 들어있음 {a:1, b:2, c:3}...
    let trs = tbody.selectAll('tr')
                    .data(mydata)

    // td에서 각 entry를 등록
    // let tds = trs.enter()
    //               .append('tr')
    //               .merge(trs)
    //               .selectAll('td')
    //               .data(k => keys.map(each_key => [each_key, k[each_key]]), tuple => tuple[0])
    // tds.enter()
    //     .append('td')
    //     .merge(tds)
    //     .text(d => d[1])

    // 동일한 코드
    // let tds = trs.enter()
    //               .append('tr')
    //               .merge(trs)
    //               .selectAll('td')
    //               .each(function(k){
    //                 let tds_each = d3.select(this)
    //                                   .data(Object.entries(k))
    //                 tds_each.enter()
    //                         .append('td')
    //                         .merge(tds_each)
    //                         .text(d=> d[1])
    //               })

    let tds = trs.enter()
                  .append('tr')
                  .merge(trs)
                  .selectAll('td')
                  .data(k => keys.map(each_key => [each_key, k[each_key]]))
                  .enter()
                  .append('td')
                  .text(d => d[1])

    // 7. brush : able to choose region interactively by mouse movements
    function getRandomNumber(range){
      return Math.floor((Math.random() * range) + 1);
    };

    function generateScatterData(){
      let scatterData = [];
      for (j of Array(100).fill(0).map((v,i) => i)) {
      scatterData.push({cx: getRandomNumber(100),
                        cy: getRandomNumber(100),
                        r: getRandomNumber(25),
                        rgb: [getRandomNumber(255), getRandomNumber(255), getRandomNumber(255)]})
                      };
      return scatterData;
    };
    let margin = 10,
        chart_margin = 25;
    let maxScore = 100;
    let totalWidth = document.getElementById("scatter_plot").clientWidth - 2*chart_margin - margin
    let scatterTotalHeight = document.getElementById("scatter_plot").clientHeight - 2*chart_margin
    let scatterXScale = d3.scaleLinear()
    // .domain([0, d3.max(scatterData, (d) => d.cx)])
    .domain([0, maxScore])
    .range([0, totalWidth]);
    let scatterYScale = d3.scaleLinear()
    // .domain([0, d3.max(scatterData, (d) => d.cy)])
    .domain([0, maxScore])
    .range([scatterTotalHeight, 0]);

    let scatterXAxis = d3.axisBottom().scale(scatterXScale).ticks(10);
    let scatterYAxis = d3.axisLeft().scale(scatterYScale).ticks(10);

    let scatterPlot = d3.select("#scatter_plot");
    const scatter = scatterPlot.append("g")
                                .attr("transform", `translate(${chart_margin+margin}, ${chart_margin-margin})`);
    scatter.append("g")
            .call(d3.axisLeft(scatterYScale));
    scatter.append("g")
            .attr("transform", `translate(0, ${scatterTotalHeight})`)
            .call(d3.axisBottom(scatterXScale));

    function drawScatterPlot(){
      let scatterData = generateScatterData();
      console.log(scatterData[10])

      let trans = d3.transition()
                    .duration(700)
                    .ease(d3.easeLinear);

      circles = scatter.selectAll("circle");
      circles.data(scatterData)
              .enter()
              .append("circle")
              .merge(circles)
              .transition(trans)
              .attr("cx", (d)=> scatterXScale(d.cx))
              .attr("cy", (d)=> scatterYScale(d.cy))
              .attr("r", (d)=> d.r)
              .attr("fill", (d)=> `rgb(${d.rgb[0]}, ${d.rgb[1]}, ${d.rgb[2]})`)
              .attr("opacity", 0.7)
              // .each((k)=>{
              //   d3.select(this).on('mouseover', (k)=>{
              //     console.log(this)
              //     d3.selectAll('.'+this.id).classed('hovered', true)
              //   });
              // })


      circles.exit().remove();
    };
    drawScatterPlot();

    //들어갈 영역
    //1차원은 brushX(), brushY()
    let brush = d3.brush()
                  .extent([[0, 0], [totalWidth, scatterTotalHeight]])
                  .on('brush', brushing)

    scatter.append('g')
            .call(brush)

    function brushing(){
      scatter.selectAll('circle')
          .classed('selected', function(k){
            let xCoord = scatterXScale(k.cx)
            let yCoord = scatterYScale(k.cy)
            let extent = d3.event.selection

            let x0 = extent[0][0]
            let y0 = extent[0][1]
            let x1 = extent[1][0]
            let y1 = extent[1][1]

            return xCoord > x0 && xCoord < x1 && yCoord > y0 && yCoord < y1
          })
    }

    // 8. linking - 한 화면에 그렸을 때, 한 시각화에서의 interaction이 다른 시각화에서도 적용되도록 하는 것
    function brushmove(p){
      let e = brush.extent()
      scatter.selectAll('circle')
              .classed('hidden', function(d) {
                return e[0][0] > d[p.x] || d[p.x] > e[1][0]
                || e[0][1] > d[p.y] || d[p.y] > e[1][1]
              })
    }

    // 9. formatting
    console.log(d3.format('.0%')(0.123))
    console.log(d3.format('$.2f')(-3.5))
    console.log(d3.format('+20')(42))
    console.log(d3.format('.^20')(42))
    console.log(d3.format('.2s')(42e6)) //SI-prefix with two significant digits
    console.log(d3.format('#x')(48879)) //prefix lowercase hexadecimal
    console.log(d3.format(',.2r')(4223))

    let parseTime = d3.timeParse('%B %d, %Y')
    console.log(parseTime('June 30, 2015'))

    let formatTime = d3.timeFormat('%B %d, %Y')
    console.log(formatTime(new Date))

    // 10. shapes
    let sample_data = [
      {date: 1, value:getRandomNumber(100)},
      {date: 2, value:getRandomNumber(100)},
      {date: 3, value:getRandomNumber(100)},
      {date: 4, value:getRandomNumber(100)},
      {date: 5, value:getRandomNumber(100)},
      {date: 6, value:getRandomNumber(100)},
    ]

    var line = d3.line()
                .x(function(d){return scatterXScale(d.date)})
                .y(function(d){return scatterYScale(d.value)})
                .curve(d3.curveMonotoneX)

    d3.select('#shape')
      .append('path')
      .datum(sample_data)
      .attr('class', 'line')
      .attr('d', line)
  </script>
</body>
</html>
