<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>2018-28420 Visualization Assignment 02: KBO data</title>
  <!-- DATA : KBO data(rank, win, tie, lose, winning rate, winning difference) from 1982 to 2017 except 1999, 2000 -->
  <style>
    /* .selected {
      fill: green;
    } */
  </style>
</head>
<body>
  <script src="https://d3js.org/d3.v5.min.js"></script>
  <div id='data_manage'>
    <h1>KBO Ranking</h1>
    <select id='year' name='year'></select>
    <select id='year' name='year'></select>
    <select id='year' name='year'></select>
  </div>
  <div id="table_container"></div>
  <svg id="line_chart" width="50%", height="400"></svg>
  <svg id="bar_chart" width="50%", height="400"></svg>
  <script type="text/javascript">
    // python3 -m http.server

    let margin = 10
    let emptySpace = '\u00A0\u00A0'

    // 1. load json
    // 2. add options data to selectors (year)
    let load = ()=>{
      let loaded_data = {}

      d3.json('data.json').then(function(data){
        // data is inserted in json format
        // must convert from string
        console.log(data)
        console.log(Object.values(data))

        data.forEach((v)=> {
          loaded_data[v['year']]=v['rankings']
        })
        addYearSelector(loaded_data)
        // d3.select('#year').property('value', Object.keys(loaded_data)[0])
        initialize_table(loaded_data)
      })
      return loaded_data
    }
    const loaded_data = load()

    function addYearSelector(loaded_data){
      //insert year data
      let yearOptions = d3.select('#year')
                            .attr('class', 'select')
                            .on('change', redraw)
                            // .attr('name', 'name-list')
                            .selectAll('option')
                            .data(Object.keys(loaded_data))
                            .enter()
                            .append('option')
      yearOptions.text((d)=> d)
                  .attr('value', (d)=>d)
    }

    // 3. draw table
    let columns = ['rank', 'team', 'W', 'D', 'L', 'win_rate', 'diff_game']//Object.keys(table_data[0])
    function initialize_table(loaded_data){
      let selectedYear = d3.select('div')
                            .select('#year')
                            .property('value')

      let table_data = loaded_data[selectedYear].sort((a, b)=> a.rank-b.rank)

      let table = d3.select('#table_container')
                    .append('table')
                    .attr("transform", `translate(${margin}, ${margin})`)
                    .attr('id', 'table')
      let thead = table.append('thead')
                        .append('tr')
                        .selectAll('th')
                        .data(columns)
      thead.enter()
            .append('th')
            .merge(thead)
            .text((k) => emptySpace+k+emptySpace)

      let tbody = table.append('tbody')
      // tr에 각 row data가 들어있음 {a:1, b:2, c:3}...
      let trs = tbody.selectAll('tr')
                      .data(table_data)

      trs.enter()
          .append('tr')
          .merge(trs)
          .selectAll('td')
          .data((k) => columns.map(each_key => k[each_key]))
          .enter()
          .append('td')
          .text((d) => emptySpace+d)
    }

    function redraw(){
      let selectedYear = d3.select('div')
                            .select('#year')
                            .property('value')

      let table_data = loaded_data[selectedYear].sort((a, b)=> a.rank-b.rank)
      console.log(selectedYear)
      console.log(table_data)

      let trans = d3.transition()
                    .duration(1700)
                    .ease(d3.easeLinear);

      let trs = d3.select('table').select('tbody')
                  .selectAll('tr')
                  .data(table_data)

      let tds = trs.enter()
        .append('tr')
        .merge(trs)
        .selectAll('td')
        .data((k) => columns.map(each_key => k[each_key]))

      tds.enter()
          .append('td')
          .merge(tds)
          .text((d)=> emptySpace+d)

      // d3.select("body")
      //  .transition()
      //  .style("background-color", "lightblue");
      trs.exit().remove()
      tds.exit().remove()
    }

    // d3.selectAll('rect')
    // d3.selectAll('#rect') = id rect
    // d3.selectAll('.rect') = class rect

    //1. chaining
    // d3.select("#table")
    //   .selectAll(".selected")

    //2. adding class
    // d3.selectAll('.foo').classed('bar', true);

    // d3.selectAll('.foo').classed('bar extra', true);

    // function 일 경우, 각 selection에 대하여 함수의 return에 따라
    // d3.selectAll('.foo')
    //   .attr('class', function(c){
    //     return d3.select(this).attr('class')+' bar'
    //   });

    // class 여부 확인을 위해
    // console.log(d3.selectAll('.foo').classed('bar'));
    //
    // // 3. each
    // d3.selectAll('.grp')
    //   .each(function(d, i, nodes){
    //     console.log(d);
    //     // d = data
    //     // i = index
    //     // nodes = selector group, nodes[i] === this
    //   });
    //
    // // 4. call : 호출 바로 앞의 객체를 매개변수로 넘겨준다
    // // use for axis and brush drawing
    // d3.selectAll('div')
    //   .call(function(div){
    //     div.classed('next_div', true);
    //   });
    //
    //   const xScale = d3.scaleBand()
    //                   .rangeRound([0, 100])
    //                   .domain([1,2,3]);
    //   const yScale = d3.scaleLinear()
    //                   .range([100, 0])
    //                   .domain([0, 5]);
    //
    // let svg = d3.select('svg');
    // svg.append('g')
    //   .attr('transform', 'translate(0, 100)')
    //   .call(d3.axisLeft(yScale))
    //   .call(d3.axisBottom(xScale));
    //
    // // 5. additional properties
    // d3.select('#checkbox_group')
    //   .selectAll('input')
    //   .property('checked', true);
    // let isChecked = d3.select('#checkbox_group')
    //                   .selectAll('input')
    //                   .property('checked');
    // console.log('check box is checked::: ' + isChecked);
    //
    // d3.select('#checkbox_group')
    //   .select('input')
    //   .text('this is a check box.');
    // console.log(d3.select('#checkbox_group')
    //               .select('input')
    //               .text());
    //
    // console.log(d3.select('#checkbox_group')
    //               .html())
    //

    //
    // // 7. brush : able to choose region interactively by mouse movements
    // function getRandomNumber(range){
    //   return Math.floor((Math.random() * range) + 1);
    // };
    //
    // function generateScatterData(){
    //   let scatterData = [];
    //   for (j of Array(100).fill(0).map((v,i) => i)) {
    //   scatterData.push({cx: getRandomNumber(100),
    //                     cy: getRandomNumber(100),
    //                     r: getRandomNumber(25),
    //                     rgb: [getRandomNumber(255), getRandomNumber(255), getRandomNumber(255)]})
    //                   };
    //   return scatterData;
    // };
    // let margin = 10,
    //     chart_margin = 25;
    // let maxScore = 100;
    // let totalWidth = document.getElementById("scatter_plot").clientWidth - 2*chart_margin - margin
    // let scatterTotalHeight = document.getElementById("scatter_plot").clientHeight - 2*chart_margin
    // let scatterXScale = d3.scaleLinear()
    // // .domain([0, d3.max(scatterData, (d) => d.cx)])
    // .domain([0, maxScore])
    // .range([0, totalWidth]);
    // let scatterYScale = d3.scaleLinear()
    // // .domain([0, d3.max(scatterData, (d) => d.cy)])
    // .domain([0, maxScore])
    // .range([scatterTotalHeight, 0]);
    //
    // let scatterXAxis = d3.axisBottom().scale(scatterXScale).ticks(10);
    // let scatterYAxis = d3.axisLeft().scale(scatterYScale).ticks(10);
    //
    // let scatterPlot = d3.select("#scatter_plot");
    // const scatter = scatterPlot.append("g")
    //                             .attr("transform", `translate(${chart_margin+margin}, ${chart_margin-margin})`);
    // scatter.append("g")
    //         .call(d3.axisLeft(scatterYScale));
    // scatter.append("g")
    //         .attr("transform", `translate(0, ${scatterTotalHeight})`)
    //         .call(d3.axisBottom(scatterXScale));
    //
    // function drawScatterPlot(){
    //   let scatterData = generateScatterData();
    //   console.log(scatterData[10])
    //
    //   let trans = d3.transition()
    //                 .duration(700)
    //                 .ease(d3.easeLinear);
    //
    //   circles = scatter.selectAll("circle");
    //   circles.data(scatterData)
    //           .enter()
    //           .append("circle")
    //           .merge(circles)
    //           .transition(trans)
    //           .attr("cx", (d)=> scatterXScale(d.cx))
    //           .attr("cy", (d)=> scatterYScale(d.cy))
    //           .attr("r", (d)=> d.r)
    //           .attr("fill", (d)=> `rgb(${d.rgb[0]}, ${d.rgb[1]}, ${d.rgb[2]})`)
    //           .attr("opacity", 0.7)
    //           // .each((k)=>{
    //           //   d3.select(this).on('mouseover', (k)=>{
    //           //     console.log(this)
    //           //     d3.selectAll('.'+this.id).classed('hovered', true)
    //           //   });
    //           // })
    //
    //
    //   circles.exit().remove();
    // };
    // drawScatterPlot();
    //
    // //들어갈 영역
    // //1차원은 brushX(), brushY()
    // let brush = d3.brush()
    //               .extent([[0, 0], [totalWidth, scatterTotalHeight]])
    //               .on('brush', brushing)
    //
    // scatter.append('g')
    //         .call(brush)
    //
    // function brushing(){
    //   scatter.selectAll('circle')
    //       .classed('selected', function(k){
    //         let xCoord = scatterXScale(k.cx)
    //         let yCoord = scatterYScale(k.cy)
    //         let extent = d3.event.selection
    //
    //         let x0 = extent[0][0]
    //         let y0 = extent[0][1]
    //         let x1 = extent[1][0]
    //         let y1 = extent[1][1]
    //
    //         return xCoord > x0 && xCoord < x1 && yCoord > y0 && yCoord < y1
    //       })
    // }
    //
    // // 8. linking - 한 화면에 그렸을 때, 한 시각화에서의 interaction이 다른 시각화에서도 적용되도록 하는 것
    // function brushmove(p){
    //   let e = brush.extent()
    //   scatter.selectAll('circle')
    //           .classed('hidden', function(d) {
    //             return e[0][0] > d[p.x] || d[p.x] > e[1][0]
    //             || e[0][1] > d[p.y] || d[p.y] > e[1][1]
    //           })
    // }
    //
    // // 9. formatting
    // console.log(d3.format('.0%')(0.123))
    // console.log(d3.format('$.2f')(-3.5))
    // console.log(d3.format('+20')(42))
    // console.log(d3.format('.^20')(42))
    // console.log(d3.format('.2s')(42e6)) //SI-prefix with two significant digits
    // console.log(d3.format('#x')(48879)) //prefix lowercase hexadecimal
    // console.log(d3.format(',.2r')(4223))
    //
    // let parseTime = d3.timeParse('%B %d, %Y')
    // console.log(parseTime('June 30, 2015'))
    //
    // let formatTime = d3.timeFormat('%B %d, %Y')
    // console.log(formatTime(new Date))
    //
    // // 10. shapes
    // let sample_data = [
    //   {date: 1, value:getRandomNumber(100)},
    //   {date: 2, value:getRandomNumber(100)},
    //   {date: 3, value:getRandomNumber(100)},
    //   {date: 4, value:getRandomNumber(100)},
    //   {date: 5, value:getRandomNumber(100)},
    //   {date: 6, value:getRandomNumber(100)},
    // ]
    //
    // var line = d3.line()
    //             .x(function(d){return scatterXScale(d.date)})
    //             .y(function(d){return scatterYScale(d.value)})
    //             .curve(d3.curveMonotoneX)
    //
    // d3.select('#shape')
    //   .append('path')
    //   .datum(sample_data)
    //   .attr('class', 'line')
    //   .attr('d', line)
  </script>
</body>
</html>
